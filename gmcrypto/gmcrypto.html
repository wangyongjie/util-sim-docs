<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>gmcrypto 加密函数 | util-sim</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="util-sim">
    
    <link rel="preload" href="/util-sim-docs/assets/css/0.styles.ae8b23e1.css" as="style"><link rel="preload" href="/util-sim-docs/assets/js/app.c2a3e5b8.js" as="script"><link rel="preload" href="/util-sim-docs/assets/js/2.936cc445.js" as="script"><link rel="preload" href="/util-sim-docs/assets/js/12.f94eb90f.js" as="script"><link rel="prefetch" href="/util-sim-docs/assets/js/10.a05e79ec.js"><link rel="prefetch" href="/util-sim-docs/assets/js/11.fabdbd75.js"><link rel="prefetch" href="/util-sim-docs/assets/js/13.3c7568b8.js"><link rel="prefetch" href="/util-sim-docs/assets/js/14.3379ab32.js"><link rel="prefetch" href="/util-sim-docs/assets/js/3.32b7dfef.js"><link rel="prefetch" href="/util-sim-docs/assets/js/4.59d6bac7.js"><link rel="prefetch" href="/util-sim-docs/assets/js/5.7817c51d.js"><link rel="prefetch" href="/util-sim-docs/assets/js/6.189607be.js"><link rel="prefetch" href="/util-sim-docs/assets/js/7.b3e7058f.js"><link rel="prefetch" href="/util-sim-docs/assets/js/8.04aa7e05.js"><link rel="prefetch" href="/util-sim-docs/assets/js/9.505350d8.js">
    <link rel="stylesheet" href="/util-sim-docs/assets/css/0.styles.ae8b23e1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/util-sim-docs/" class="home-link router-link-active"><!----> <span class="site-name">util-sim</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/util-sim-docs/installation.html" class="nav-link">
  指南
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/util-sim-docs/installation.html" class="nav-link">
  指南
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/util-sim-docs/installation.html" class="sidebar-link">快速上手</a></li><li><a href="/util-sim-docs/changelog.html" class="sidebar-link">更新日志</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>工具函数</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/util-sim-docs/validate/validate.html" class="sidebar-link">validate 校验函数</a></li><li><a href="/util-sim-docs/common/common.html" class="sidebar-link">common 日常工具函数</a></li><li><a href="/util-sim-docs/gmcrypto/gmcrypto.html" aria-current="page" class="active sidebar-link">gmcrypto 加密函数</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="gmcrypto-加密函数"><a href="#gmcrypto-加密函数" class="header-anchor">#</a> gmcrypto 加密函数</h2> <h4 id="_1-国密加密方法简介"><a href="#_1-国密加密方法简介" class="header-anchor">#</a> 1，国密加密方法简介</h4> <p>国密算法，即国家商用密码算法。是由国家密码管理局认定和公布的密码算法标准及其应用规范，其中部分密码算法已经成为国际标准。如SM系列密码，SM代表商密，即商业密码，是指用于商业的、不涉及国家秘密的密码技术。</p> <h5 id="_1-1、sm1是一种分组加密算法"><a href="#_1-1、sm1是一种分组加密算法" class="header-anchor">#</a> 1.1、SM1是一种分组加密算法</h5> <p>对称加密算法中的分组加密算法，其分组长度、秘钥长度都是128bit，算法安全保密强度跟 AES 相当，但是算法不公开，仅以IP核的形式存在于芯片中，需要通过加密芯片的接口进行调用。</p> <p>采用该算法已经研制了系列芯片、智能IC卡、智能密码钥匙、加密卡、加密机等安全产品，广泛应用于电子政务、电子商务及国民经济的各个应用领域(包括国家政务通、警务通等重要领域)。</p> <h5 id="_1-2、sm2是非对称加密算法"><a href="#_1-2、sm2是非对称加密算法" class="header-anchor">#</a> 1.2、SM2是非对称加密算法</h5> <p>它是基于椭圆曲线密码的公钥密码算法标准，其秘钥长度256bit，包含数字签名、密钥交换和公钥加密，用于替换RSA/DH/ECDSA/ECDH等国际算法。可以满足电子认证服务系统等应用需求，由国家密码管理局于2010年12月17号发布。</p> <p>SM2采用的是ECC 256位的一种，其安全强度比RSA 2048位高，且运算速度快于RSA。</p> <h5 id="_1-3、sm3是一种密码杂凑算法"><a href="#_1-3、sm3是一种密码杂凑算法" class="header-anchor">#</a> 1.3、SM3是一种密码杂凑算法</h5> <p>用于替代MD5/SHA-1/SHA-2等国际算法，适用于数字签名和验证、消息认证码的生成与验证以及随机数的生成，可以满足电子认证服务系统等应用需求，于2010年12月17日发布。</p> <p>它是在SHA-256基础上改进实现的一种算法，采用Merkle-Damgard结构，消息分组长度为512bit，输出的摘要值长度为256bit。</p> <h5 id="_1-4、sm4是分组加密算法"><a href="#_1-4、sm4是分组加密算法" class="header-anchor">#</a> 1.4、SM4是分组加密算法</h5> <p>跟SM1类似，是我国自主设计的分组对称密码算法，用于替代DES/AES等国际算法。SM4算法与AES算法具有相同的密钥长度、分组长度，都是128bit。于2012年3月21日发布，适用于密码应用中使用分组密码的需求。</p> <h5 id="_1-5、sm7也是一种分组加密算法"><a href="#_1-5、sm7也是一种分组加密算法" class="header-anchor">#</a> 1.5、SM7也是一种分组加密算法</h5> <p>该算法没有公开。SM7适用于非接IC卡应用包括身份识别类应用(门禁卡、工作证、参赛证)，票务类应用(大型赛事门票、展会门票)，支付与通卡类应用(积分消费卡、校园一卡通、企业一卡通、公交一卡通)。</p> <h5 id="_1-6、sm9是基于标识的非对称密码算法"><a href="#_1-6、sm9是基于标识的非对称密码算法" class="header-anchor">#</a> 1.6、SM9是基于标识的非对称密码算法</h5> <p>用椭圆曲线对实现的基于标识的数字签名算法、密钥交换协议、密钥封装机制和公钥加密与解密算法，包括数字签名生成算法和验证算法，并给出了数字签名与验证算法及其相应的流程。并提供了相应的流程。可以替代基于数字证书的PKI/CA体系。</p> <h5 id="_1-7、sm9主要用于用户的身份认证。据新华网公开报道-sm9的加密强度等同于3072位密钥的rsa加密算法-于2016年3月28日发布。"><a href="#_1-7、sm9主要用于用户的身份认证。据新华网公开报道-sm9的加密强度等同于3072位密钥的rsa加密算法-于2016年3月28日发布。" class="header-anchor">#</a> 1.7、SM9主要用于用户的身份认证。据新华网公开报道，SM9的加密强度等同于3072位密钥的RSA加密算法，于2016年3月28日发布。</h5> <p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。</p> <p>由于SM1、SM4加解密的分组大小为128bit，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。</p> <h2 id="sm2经验分享"><a href="#sm2经验分享" class="header-anchor">#</a> SM2经验分享</h2> <h3 id="过去项目中使用sm2的比较多-所以分享下使用sm2的一些经验"><a href="#过去项目中使用sm2的比较多-所以分享下使用sm2的一些经验" class="header-anchor">#</a> 过去项目中使用SM2的比较多，所以分享下使用SM2的一些经验</h3> <p>1.安装包: npm i sm-crypto --save</p> <p>2.引入包：const sm2 = require('sm-crypto').sm2 / import { sm2 } from 'sm-crypto';</p> <p>在前后端分离的项目中，一般由后端人员提供一对公钥跟私钥，对于非对称加密方法来说，公钥加密私钥解密，私钥加签公钥验签。</p> <p>还需要说的一些小知识就是，有些项目中，会存在签名（数据加签）和加密（数据加密）的情况，一般来说，数据加签用私钥，数据加密用公钥。</p> <h4 id="公钥"><a href="#公钥" class="header-anchor">#</a> //公钥</h4> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>const PBLICKEY = '041a9f945535fb9be8f9ae11299a82baa99762ebdea672a902c85c98
6d70fd4b8dc841b062ff0cf964a930ae4a0ac3cedbaf1f46f983f60d3bb68f3f27a89a8b7c'</p></div> <h4 id="私钥"><a href="#私钥" class="header-anchor">#</a> //私钥</h4> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>const PRIVATEKEY = '16e73c8c3646d7d724efb8fa56e2616da6a824ae81ad6c91026b2a05d1c2d0e1'</p></div> <h4 id="加密"><a href="#加密" class="header-anchor">#</a> // 加密</h4> <p>export function setEncrypt(msg) {</p> <p>const pubKey = <code>${PBLICKEY}</code>; // 公钥</p> <p>const cipherMode = 1; // 1 - C1C3C2，0 - C1C2C3，默认为1</p> <p>const encryptData = sm2.doEncrypt(msg, pubKey, cipherMode); // 加密结果</p> <p>return encryptData;</p> <p>}</p> <h4 id="解密"><a href="#解密" class="header-anchor">#</a> // 解密</h4> <p>export function decrypt(msg) {</p> <p>const priKey = <code>${PRIVATEKEY}</code>; // 私钥</p> <p>const cipherMode = 1; // 1 - C1C3C2，0 - C1C2C3，默认为1</p> <p>const decryptData = sm2.doDecrypt(msg, priKey, cipherMode); // 解密结果</p> <p>return decryptData;</p> <p>}</p> <h4 id="_3-在数据加密是需要使用公钥去加密-下面的例子是在vue项目中封装sm2的加解密方法"><a href="#_3-在数据加密是需要使用公钥去加密-下面的例子是在vue项目中封装sm2的加解密方法" class="header-anchor">#</a> 3.在数据加密是需要使用公钥去加密，下面的例子是在vue项目中封装SM2的加解密方法</h4> <p>// 在vue项目中加密</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>export function sm2encrypt(txt) {</p> <p>return SM2.encrypt(txt, publicKey, {
inputEncoding: 'utf8',
outputEncoding: 'base64',
pc: true
})</p> <p>}</p></div> <p>// 在vue项目中解密</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>export function sm2decrypt(txt) {</p> <p>return SM2.decrypt(txt, publicKey, {
inputEncoding: 'utf8',
outputEncoding: 'base64',
})</p> <p>}</p></div> <h4 id="_4-在一些特殊的情景下-我们需要数据加签-签名-来提高传输过程中的安全性-签名是用私钥"><a href="#_4-在一些特殊的情景下-我们需要数据加签-签名-来提高传输过程中的安全性-签名是用私钥" class="header-anchor">#</a> 4.在一些特殊的情景下，我们需要数据加签（签名）来提高传输过程中的安全性，签名是用私钥</h4> <p>//在vue项目中的签名</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>export function doSign(data){
return sm2.doSignature(JSON.stringify(data), privateKey, {
hash: true,
der: true
})
}</p></div> <h4 id="【注意】"><a href="#【注意】" class="header-anchor">#</a> 【注意】：</h4> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>1，公钥是原始密码格式，也就是一个32字节的整数值，切记，不然签名一直不通，所以看到公钥会比私钥短；</p> <p>2，使用SM2签名，需要对签名的参数（参数是一个{}）进行排序，而且是按key的升序排序，可以使用下面方法</p> <p>Object.keys(obj).sort().forEach((item) =&gt; {
objData[item] = obj[item];
});</p> <p>3，当参数按照key排序好，需要将对象转化成一个字符窜，在doSign方法里面，已经调用SON.stringify(），所以可以直接调用doSign方法，</p> <p>4，当调用完doSign（）之后，会返回一窜密文，但还需要将密文地要用</p> <p>CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(signature))</p> <p>格式转化，最终才算这个签名参数完成，因为要格式转换，所以需要引用CryptoJS</p> <p>import CryptoJS from &quot;crypto-js&quot;;</p> <p>同时也要安装crypto-js这个包，crypto-js这个就不在这里展开说了</p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/util-sim-docs/common/common.html" class="prev">
        common 日常工具函数
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/util-sim-docs/assets/js/app.c2a3e5b8.js" defer></script><script src="/util-sim-docs/assets/js/2.936cc445.js" defer></script><script src="/util-sim-docs/assets/js/12.f94eb90f.js" defer></script>
  </body>
</html>
